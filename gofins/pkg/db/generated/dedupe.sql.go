// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dedupe.sql

package generated

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const getStockSymbolsForNameDedupe = `-- name: GetStockSymbolsForNameDedupe :many
SELECT ticker, name, oldest_price, primary_listing
FROM symbols
WHERE (type = $1 OR type IS NULL)
  AND name IS NOT NULL
ORDER BY name, oldest_price ASC NULLS LAST
`

type GetStockSymbolsForNameDedupeRow struct {
	Ticker         string         `json:"ticker"`
	Name           sql.NullString `json:"name"`
	OldestPrice    sql.NullTime   `json:"oldest_price"`
	PrimaryListing sql.NullString `json:"primary_listing"`
}

func (q *Queries) GetStockSymbolsForNameDedupe(ctx context.Context, type_ sql.NullString) ([]GetStockSymbolsForNameDedupeRow, error) {
	rows, err := q.db.QueryContext(ctx, getStockSymbolsForNameDedupe, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStockSymbolsForNameDedupeRow{}
	for rows.Next() {
		var i GetStockSymbolsForNameDedupeRow
		if err := rows.Scan(
			&i.Ticker,
			&i.Name,
			&i.OldestPrice,
			&i.PrimaryListing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockSymbolsWithoutCIK = `-- name: GetStockSymbolsWithoutCIK :many
SELECT ticker, name, oldest_price, primary_listing
FROM symbols
WHERE (cik IS NULL OR cik = '')
  AND (type = $1 OR type IS NULL)
  AND name IS NOT NULL
ORDER BY name, oldest_price ASC NULLS LAST
`

type GetStockSymbolsWithoutCIKRow struct {
	Ticker         string         `json:"ticker"`
	Name           sql.NullString `json:"name"`
	OldestPrice    sql.NullTime   `json:"oldest_price"`
	PrimaryListing sql.NullString `json:"primary_listing"`
}

func (q *Queries) GetStockSymbolsWithoutCIK(ctx context.Context, type_ sql.NullString) ([]GetStockSymbolsWithoutCIKRow, error) {
	rows, err := q.db.QueryContext(ctx, getStockSymbolsWithoutCIK, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStockSymbolsWithoutCIKRow{}
	for rows.Next() {
		var i GetStockSymbolsWithoutCIKRow
		if err := rows.Scan(
			&i.Ticker,
			&i.Name,
			&i.OldestPrice,
			&i.PrimaryListing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSymbolsWithCIK = `-- name: GetSymbolsWithCIK :many
SELECT ticker, exchange, cik, primary_listing
FROM symbols
WHERE cik IS NOT NULL AND cik != ''
  AND (type = $1 OR type IS NULL)
ORDER BY cik, exchange
`

type GetSymbolsWithCIKRow struct {
	Ticker         string         `json:"ticker"`
	Exchange       sql.NullString `json:"exchange"`
	Cik            sql.NullString `json:"cik"`
	PrimaryListing sql.NullString `json:"primary_listing"`
}

func (q *Queries) GetSymbolsWithCIK(ctx context.Context, type_ sql.NullString) ([]GetSymbolsWithCIKRow, error) {
	rows, err := q.db.QueryContext(ctx, getSymbolsWithCIK, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSymbolsWithCIKRow{}
	for rows.Next() {
		var i GetSymbolsWithCIKRow
		if err := rows.Scan(
			&i.Ticker,
			&i.Exchange,
			&i.Cik,
			&i.PrimaryListing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetPrimaryListings = `-- name: ResetPrimaryListings :execrows
UPDATE symbols SET primary_listing = NULL
`

func (q *Queries) ResetPrimaryListings(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, resetPrimaryListings)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setPrimaryListing = `-- name: SetPrimaryListing :exec
UPDATE symbols SET primary_listing = '' WHERE ticker = $1
`

func (q *Queries) SetPrimaryListing(ctx context.Context, ticker string) error {
	_, err := q.db.ExecContext(ctx, setPrimaryListing, ticker)
	return err
}

const setSecondaryListings = `-- name: SetSecondaryListings :exec
UPDATE symbols SET primary_listing = $1 WHERE ticker = ANY($2::text[])
`

type SetSecondaryListingsParams struct {
	PrimaryListing sql.NullString `json:"primary_listing"`
	Column2        []string       `json:"column_2"`
}

func (q *Queries) SetSecondaryListings(ctx context.Context, arg SetSecondaryListingsParams) error {
	_, err := q.db.ExecContext(ctx, setSecondaryListings, arg.PrimaryListing, pq.Array(arg.Column2))
	return err
}
