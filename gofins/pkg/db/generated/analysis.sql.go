// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analysis.sql

package generated

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createAnalysisPackage = `-- name: CreateAnalysisPackage :exec
INSERT INTO analysis_packages (
    id, name, created_at, interval, time_from, time_to,
    hist_bins, hist_min, hist_max, mcap_min, inception_max, status, user_id
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
`

type CreateAnalysisPackageParams struct {
	ID           uuid.UUID     `json:"id"`
	Name         string        `json:"name"`
	CreatedAt    time.Time     `json:"created_at"`
	Interval     string        `json:"interval"`
	TimeFrom     time.Time     `json:"time_from"`
	TimeTo       time.Time     `json:"time_to"`
	HistBins     int32         `json:"hist_bins"`
	HistMin      float64       `json:"hist_min"`
	HistMax      float64       `json:"hist_max"`
	McapMin      sql.NullInt64 `json:"mcap_min"`
	InceptionMax sql.NullTime  `json:"inception_max"`
	Status       string        `json:"status"`
	UserID       uuid.UUID     `json:"user_id"`
}

func (q *Queries) CreateAnalysisPackage(ctx context.Context, arg CreateAnalysisPackageParams) error {
	_, err := q.db.ExecContext(ctx, createAnalysisPackage,
		arg.ID,
		arg.Name,
		arg.CreatedAt,
		arg.Interval,
		arg.TimeFrom,
		arg.TimeTo,
		arg.HistBins,
		arg.HistMin,
		arg.HistMax,
		arg.McapMin,
		arg.InceptionMax,
		arg.Status,
		arg.UserID,
	)
	return err
}

const deleteAnalysisPackage = `-- name: DeleteAnalysisPackage :exec
DELETE FROM analysis_packages 
WHERE id = $1 AND user_id = $2
`

type DeleteAnalysisPackageParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteAnalysisPackage(ctx context.Context, arg DeleteAnalysisPackageParams) error {
	_, err := q.db.ExecContext(ctx, deleteAnalysisPackage, arg.ID, arg.UserID)
	return err
}

const getAnalysisPackage = `-- name: GetAnalysisPackage :one
SELECT id, name, created_at, interval, time_from, time_to,
       hist_bins, hist_min, hist_max, mcap_min, inception_max, symbol_count, status, user_id
FROM analysis_packages
WHERE id = $1 AND user_id = $2
`

type GetAnalysisPackageParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetAnalysisPackage(ctx context.Context, arg GetAnalysisPackageParams) (AnalysisPackage, error) {
	row := q.db.QueryRowContext(ctx, getAnalysisPackage, arg.ID, arg.UserID)
	var i AnalysisPackage
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.Interval,
		&i.TimeFrom,
		&i.TimeTo,
		&i.HistBins,
		&i.HistMin,
		&i.HistMax,
		&i.McapMin,
		&i.InceptionMax,
		&i.SymbolCount,
		&i.Status,
		&i.UserID,
	)
	return i, err
}

const getAnalysisResults = `-- name: GetAnalysisResults :many
SELECT ar.package_id, ar.ticker, ar.count, ar.mean, ar.stddev, ar.variance, ar.min, ar.max, s.inception
FROM analysis_results ar
JOIN symbols s ON ar.ticker = s.ticker
WHERE ar.package_id = $1
ORDER BY ar.mean DESC
`

type GetAnalysisResultsRow struct {
	PackageID uuid.UUID    `json:"package_id"`
	Ticker    string       `json:"ticker"`
	Count     int32        `json:"count"`
	Mean      float64      `json:"mean"`
	Stddev    float64      `json:"stddev"`
	Variance  float64      `json:"variance"`
	Min       float64      `json:"min"`
	Max       float64      `json:"max"`
	Inception sql.NullTime `json:"inception"`
}

func (q *Queries) GetAnalysisResults(ctx context.Context, packageID uuid.UUID) ([]GetAnalysisResultsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAnalysisResults, packageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAnalysisResultsRow{}
	for rows.Next() {
		var i GetAnalysisResultsRow
		if err := rows.Scan(
			&i.PackageID,
			&i.Ticker,
			&i.Count,
			&i.Mean,
			&i.Stddev,
			&i.Variance,
			&i.Min,
			&i.Max,
			&i.Inception,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAnalysisPackages = `-- name: ListAnalysisPackages :many
SELECT id, name, created_at, interval, time_from, time_to,
       hist_bins, hist_min, hist_max, mcap_min, inception_max, symbol_count, status, user_id
FROM analysis_packages
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAnalysisPackages(ctx context.Context, userID uuid.UUID) ([]AnalysisPackage, error) {
	rows, err := q.db.QueryContext(ctx, listAnalysisPackages, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AnalysisPackage{}
	for rows.Next() {
		var i AnalysisPackage
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.Interval,
			&i.TimeFrom,
			&i.TimeTo,
			&i.HistBins,
			&i.HistMin,
			&i.HistMax,
			&i.McapMin,
			&i.InceptionMax,
			&i.SymbolCount,
			&i.Status,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveAnalysisResult = `-- name: SaveAnalysisResult :exec
INSERT INTO analysis_results (
    package_id, ticker, count, mean, stddev, variance, min, max, histogram
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type SaveAnalysisResultParams struct {
	PackageID uuid.UUID       `json:"package_id"`
	Ticker    string          `json:"ticker"`
	Count     int32           `json:"count"`
	Mean      float64         `json:"mean"`
	Stddev    float64         `json:"stddev"`
	Variance  float64         `json:"variance"`
	Min       float64         `json:"min"`
	Max       float64         `json:"max"`
	Histogram json.RawMessage `json:"histogram"`
}

func (q *Queries) SaveAnalysisResult(ctx context.Context, arg SaveAnalysisResultParams) error {
	_, err := q.db.ExecContext(ctx, saveAnalysisResult,
		arg.PackageID,
		arg.Ticker,
		arg.Count,
		arg.Mean,
		arg.Stddev,
		arg.Variance,
		arg.Min,
		arg.Max,
		arg.Histogram,
	)
	return err
}

const updateAnalysisPackageName = `-- name: UpdateAnalysisPackageName :exec
UPDATE analysis_packages 
SET name = $1 
WHERE id = $2 AND user_id = $3
`

type UpdateAnalysisPackageNameParams struct {
	Name   string    `json:"name"`
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateAnalysisPackageName(ctx context.Context, arg UpdateAnalysisPackageNameParams) error {
	_, err := q.db.ExecContext(ctx, updateAnalysisPackageName, arg.Name, arg.ID, arg.UserID)
	return err
}

const updateAnalysisPackageStatus = `-- name: UpdateAnalysisPackageStatus :exec
UPDATE analysis_packages 
SET status = $1, symbol_count = $2 
WHERE id = $3 AND user_id = $4
`

type UpdateAnalysisPackageStatusParams struct {
	Status      string        `json:"status"`
	SymbolCount sql.NullInt32 `json:"symbol_count"`
	ID          uuid.UUID     `json:"id"`
	UserID      uuid.UUID     `json:"user_id"`
}

func (q *Queries) UpdateAnalysisPackageStatus(ctx context.Context, arg UpdateAnalysisPackageStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateAnalysisPackageStatus,
		arg.Status,
		arg.SymbolCount,
		arg.ID,
		arg.UserID,
	)
	return err
}

const verifyPackageOwnership = `-- name: VerifyPackageOwnership :one
SELECT EXISTS(SELECT 1 FROM analysis_packages WHERE id = $1 AND user_id = $2)
`

type VerifyPackageOwnershipParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) VerifyPackageOwnership(ctx context.Context, arg VerifyPackageOwnershipParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, verifyPackageOwnership, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
