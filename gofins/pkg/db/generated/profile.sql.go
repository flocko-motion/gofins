// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: profile.sql

package generated

import (
	"context"
	"database/sql"
)

const countActivelyTrading = `-- name: CountActivelyTrading :one
SELECT COUNT(*) FROM symbols WHERE is_actively_trading = true
`

func (q *Queries) CountActivelyTrading(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivelyTrading)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStaleProfiles = `-- name: CountStaleProfiles :one
SELECT COUNT(*) FROM symbols
WHERE (last_profile_update IS NULL OR last_profile_update < $1)
  AND (type IS NULL OR type != $2)
`

type CountStaleProfilesParams struct {
	LastProfileUpdate sql.NullTime   `json:"last_profile_update"`
	Type              sql.NullString `json:"type"`
}

func (q *Queries) CountStaleProfiles(ctx context.Context, arg CountStaleProfilesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countStaleProfiles, arg.LastProfileUpdate, arg.Type)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSymbols = `-- name: CountSymbols :one
SELECT COUNT(*) FROM symbols
`

func (q *Queries) CountSymbols(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSymbols)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllSymbolCurrencies = `-- name: GetAllSymbolCurrencies :many
SELECT ticker, COALESCE(currency, 'USD') as currency
FROM symbols
`

type GetAllSymbolCurrenciesRow struct {
	Ticker   string `json:"ticker"`
	Currency string `json:"currency"`
}

func (q *Queries) GetAllSymbolCurrencies(ctx context.Context) ([]GetAllSymbolCurrenciesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllSymbolCurrencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllSymbolCurrenciesRow{}
	for rows.Next() {
		var i GetAllSymbolCurrenciesRow
		if err := rows.Scan(&i.Ticker, &i.Currency); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTickers = `-- name: GetAllTickers :many
SELECT ticker FROM symbols
`

func (q *Queries) GetAllTickers(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getAllTickers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var ticker string
		if err := rows.Scan(&ticker); err != nil {
			return nil, err
		}
		items = append(items, ticker)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOldestProfileUpdate = `-- name: GetOldestProfileUpdate :one
SELECT MIN(last_profile_update) FROM symbols
WHERE last_profile_update IS NOT NULL
`

func (q *Queries) GetOldestProfileUpdate(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getOldestProfileUpdate)
	var min interface{}
	err := row.Scan(&min)
	return min, err
}

const getStaleProfiles = `-- name: GetStaleProfiles :many
SELECT ticker FROM symbols
WHERE (last_profile_update IS NULL OR last_profile_update < $1)
  AND (type IS NULL OR type != $2)
  AND (primary_listing IS NULL OR primary_listing = '')
ORDER BY last_profile_update ASC NULLS FIRST
LIMIT $3
`

type GetStaleProfilesParams struct {
	LastProfileUpdate sql.NullTime   `json:"last_profile_update"`
	Type              sql.NullString `json:"type"`
	Limit             int32          `json:"limit"`
}

func (q *Queries) GetStaleProfiles(ctx context.Context, arg GetStaleProfilesParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getStaleProfiles, arg.LastProfileUpdate, arg.Type, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var ticker string
		if err := rows.Scan(&ticker); err != nil {
			return nil, err
		}
		items = append(items, ticker)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSymbol = `-- name: GetSymbol :one
SELECT s.ticker, s.exchange, s.last_price_update, s.last_profile_update,
       s.last_price_status, s.last_profile_status,
       s.name, s.type, s.currency, s.sector, s.industry, s.country,
       s.description, s.website, s.isin, s.cik, s.inception, s.oldest_price, 
       s.is_actively_trading, s.market_cap, s.primary_listing,
       s.ath12m, s.current_price_usd, s.current_price_time,
       COALESCE(f.ticker IS NOT NULL, false) as is_favorite
FROM symbols s
LEFT JOIN user_favorites f ON s.ticker = f.ticker
WHERE s.ticker = $1
`

type GetSymbolRow struct {
	Ticker            string          `json:"ticker"`
	Exchange          sql.NullString  `json:"exchange"`
	LastPriceUpdate   sql.NullTime    `json:"last_price_update"`
	LastProfileUpdate sql.NullTime    `json:"last_profile_update"`
	LastPriceStatus   sql.NullString  `json:"last_price_status"`
	LastProfileStatus sql.NullString  `json:"last_profile_status"`
	Name              sql.NullString  `json:"name"`
	Type              sql.NullString  `json:"type"`
	Currency          sql.NullString  `json:"currency"`
	Sector            sql.NullString  `json:"sector"`
	Industry          sql.NullString  `json:"industry"`
	Country           sql.NullString  `json:"country"`
	Description       sql.NullString  `json:"description"`
	Website           sql.NullString  `json:"website"`
	Isin              sql.NullString  `json:"isin"`
	Cik               sql.NullString  `json:"cik"`
	Inception         sql.NullTime    `json:"inception"`
	OldestPrice       sql.NullTime    `json:"oldest_price"`
	IsActivelyTrading sql.NullBool    `json:"is_actively_trading"`
	MarketCap         sql.NullInt64   `json:"market_cap"`
	PrimaryListing    sql.NullString  `json:"primary_listing"`
	Ath12m            sql.NullFloat64 `json:"ath12m"`
	CurrentPriceUsd   sql.NullFloat64 `json:"current_price_usd"`
	CurrentPriceTime  sql.NullTime    `json:"current_price_time"`
	IsFavorite        interface{}     `json:"is_favorite"`
}

func (q *Queries) GetSymbol(ctx context.Context, ticker string) (GetSymbolRow, error) {
	row := q.db.QueryRowContext(ctx, getSymbol, ticker)
	var i GetSymbolRow
	err := row.Scan(
		&i.Ticker,
		&i.Exchange,
		&i.LastPriceUpdate,
		&i.LastProfileUpdate,
		&i.LastPriceStatus,
		&i.LastProfileStatus,
		&i.Name,
		&i.Type,
		&i.Currency,
		&i.Sector,
		&i.Industry,
		&i.Country,
		&i.Description,
		&i.Website,
		&i.Isin,
		&i.Cik,
		&i.Inception,
		&i.OldestPrice,
		&i.IsActivelyTrading,
		&i.MarketCap,
		&i.PrimaryListing,
		&i.Ath12m,
		&i.CurrentPriceUsd,
		&i.CurrentPriceTime,
		&i.IsFavorite,
	)
	return i, err
}

const getTickersNeedingProfileUpdate = `-- name: GetTickersNeedingProfileUpdate :many
SELECT ticker 
FROM symbols 
WHERE last_profile_update IS NULL 
   OR last_profile_update < $1
`

func (q *Queries) GetTickersNeedingProfileUpdate(ctx context.Context, lastProfileUpdate sql.NullTime) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getTickersNeedingProfileUpdate, lastProfileUpdate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var ticker string
		if err := rows.Scan(&ticker); err != nil {
			return nil, err
		}
		items = append(items, ticker)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTickersNeedingQuoteUpdate = `-- name: GetTickersNeedingQuoteUpdate :many
SELECT ticker 
FROM symbols 
WHERE current_price_time IS NULL 
   OR current_price_time < $1
`

func (q *Queries) GetTickersNeedingQuoteUpdate(ctx context.Context, currentPriceTime sql.NullTime) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getTickersNeedingQuoteUpdate, currentPriceTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var ticker string
		if err := rows.Scan(&ticker); err != nil {
			return nil, err
		}
		items = append(items, ticker)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markStaleProfilesAsNotFound = `-- name: MarkStaleProfilesAsNotFound :execrows
UPDATE symbols
SET last_profile_status = $1
WHERE last_profile_update < $2
   OR last_profile_update IS NULL
`

type MarkStaleProfilesAsNotFoundParams struct {
	LastProfileStatus sql.NullString `json:"last_profile_status"`
	LastProfileUpdate sql.NullTime   `json:"last_profile_update"`
}

func (q *Queries) MarkStaleProfilesAsNotFound(ctx context.Context, arg MarkStaleProfilesAsNotFoundParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, markStaleProfilesAsNotFound, arg.LastProfileStatus, arg.LastProfileUpdate)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const resetIndexTimestamps = `-- name: ResetIndexTimestamps :execrows
UPDATE symbols 
SET last_price_update = NULL, 
    last_price_status = NULL,
    last_profile_update = NULL,
    last_profile_status = NULL,
    is_actively_trading = true
WHERE type = $1
`

func (q *Queries) ResetIndexTimestamps(ctx context.Context, type_ sql.NullString) (int64, error) {
	result, err := q.db.ExecContext(ctx, resetIndexTimestamps, type_)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const resetPriceTimestamps = `-- name: ResetPriceTimestamps :execrows
UPDATE symbols 
SET last_price_update = NULL, last_price_status = NULL
`

func (q *Queries) ResetPriceTimestamps(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, resetPriceTimestamps)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const resetProfileTimestamps = `-- name: ResetProfileTimestamps :execrows
UPDATE symbols 
SET last_profile_update = NULL, last_profile_status = NULL
`

func (q *Queries) ResetProfileTimestamps(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, resetProfileTimestamps)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const resetQuoteTimestamps = `-- name: ResetQuoteTimestamps :execrows
UPDATE symbols 
SET current_price_time = NULL
`

func (q *Queries) ResetQuoteTimestamps(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, resetQuoteTimestamps)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const resetSymbol = `-- name: ResetSymbol :execrows
UPDATE symbols 
SET last_price_update = NULL, last_price_status = NULL,
    last_profile_update = NULL, last_profile_status = NULL
WHERE ticker = $1
`

func (q *Queries) ResetSymbol(ctx context.Context, ticker string) (int64, error) {
	result, err := q.db.ExecContext(ctx, resetSymbol, ticker)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
