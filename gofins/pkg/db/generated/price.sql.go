// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: price.sql

package generated

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const countStalePrices = `-- name: CountStalePrices :one
SELECT COUNT(*) FROM symbols
WHERE (last_price_update IS NULL OR last_price_update < $1)
  AND is_actively_trading = true
  AND type = ANY($2::text[])
`

type CountStalePricesParams struct {
	LastPriceUpdate sql.NullTime `json:"last_price_update"`
	Column2         []string     `json:"column_2"`
}

func (q *Queries) CountStalePrices(ctx context.Context, arg CountStalePricesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countStalePrices, arg.LastPriceUpdate, pq.Array(arg.Column2))
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFilteredTickers = `-- name: GetFilteredTickers :many
SELECT DISTINCT s.ticker FROM symbols s
WHERE s.is_actively_trading = true
  AND s.type = ANY($1::text[])
  AND ($2::BIGINT IS NULL OR s.market_cap >= $2)
  AND ($3::TIMESTAMP IS NULL OR s.inception <= $3)
  AND s.last_price_status = $4
  AND s.last_price_update IS NOT NULL
  AND s.exchange NOT IN ('OTC','PINK', 'GREY', 'OTCQB', 'OTCQX')
ORDER BY s.ticker
`

type GetFilteredTickersParams struct {
	Column1         []string       `json:"column_1"`
	Column2         int64          `json:"column_2"`
	Column3         time.Time      `json:"column_3"`
	LastPriceStatus sql.NullString `json:"last_price_status"`
}

func (q *Queries) GetFilteredTickers(ctx context.Context, arg GetFilteredTickersParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getFilteredTickers,
		pq.Array(arg.Column1),
		arg.Column2,
		arg.Column3,
		arg.LastPriceStatus,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var ticker string
		if err := rows.Scan(&ticker); err != nil {
			return nil, err
		}
		items = append(items, ticker)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOldestPriceDate = `-- name: GetOldestPriceDate :one
SELECT MIN(date) 
FROM monthly_prices 
WHERE symbol_ticker = $1
`

func (q *Queries) GetOldestPriceDate(ctx context.Context, symbolTicker string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getOldestPriceDate, symbolTicker)
	var min interface{}
	err := row.Scan(&min)
	return min, err
}

const getOldestPriceUpdate = `-- name: GetOldestPriceUpdate :one
SELECT MIN(last_price_update) FROM symbols
WHERE last_price_update IS NOT NULL
  AND is_actively_trading = true
`

func (q *Queries) GetOldestPriceUpdate(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getOldestPriceUpdate)
	var min interface{}
	err := row.Scan(&min)
	return min, err
}

const getSymbolsWithStalePrices = `-- name: GetSymbolsWithStalePrices :many
SELECT ticker, currency FROM symbols
WHERE (last_price_update IS NULL OR last_price_update < $1)
  AND is_actively_trading = true
  AND type = ANY($2::text[])
ORDER BY last_price_update ASC NULLS FIRST
LIMIT $3
`

type GetSymbolsWithStalePricesParams struct {
	LastPriceUpdate sql.NullTime `json:"last_price_update"`
	Column2         []string     `json:"column_2"`
	Limit           int32        `json:"limit"`
}

type GetSymbolsWithStalePricesRow struct {
	Ticker   string         `json:"ticker"`
	Currency sql.NullString `json:"currency"`
}

func (q *Queries) GetSymbolsWithStalePrices(ctx context.Context, arg GetSymbolsWithStalePricesParams) ([]GetSymbolsWithStalePricesRow, error) {
	rows, err := q.db.QueryContext(ctx, getSymbolsWithStalePrices, arg.LastPriceUpdate, pq.Array(arg.Column2), arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSymbolsWithStalePricesRow{}
	for rows.Next() {
		var i GetSymbolsWithStalePricesRow
		if err := rows.Scan(&i.Ticker, &i.Currency); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTickersWithPrices = `-- name: GetTickersWithPrices :many
SELECT DISTINCT symbol_ticker FROM monthly_prices 
ORDER BY symbol_ticker 
LIMIT $1
`

func (q *Queries) GetTickersWithPrices(ctx context.Context, limit int32) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getTickersWithPrices, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var symbol_ticker string
		if err := rows.Scan(&symbol_ticker); err != nil {
			return nil, err
		}
		items = append(items, symbol_ticker)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
